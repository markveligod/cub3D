# :black_square_button: Cub3d(project 2020)
## Table of contents  <a name="table"></a>
 
* [Project description](#description)
* [What is Ray-casting ?](#whatis)
* [RAY-CASTING AND/VS RAY-TRACING](#casandtra)
* [LIMITATIONS OF RAY-CASTING](#limit)
* [RAY-CASTING STEP 1: CREATING A WORLD](#step1)
* [RAY-CASTING STEP 2: DEFINING PROJECTION ATTRIBUTES](#step2)
* [RAY-CASTING STEP 3: FINDING WALLS](#step3)
* [RAY-CASTING STEP 4: FINDING DISTANCE TO WALLS](#step4)
* [RAY-CASTING STEP 5: DRAWING WALLS](#step5)
* [TEXTURE MAPPED WALLS](#texture)
* [DRAWING FLOORS](#floors)
* [DRAWING CEILINGS](#ceilings)
* [VARIABLE HEIGHT WALLS](#walls)
* [HORIZONTAL MOTION](#hor)
* [VERTICAL MOTION: LOOKING UP AND DOWN ](#ver)  
* [SHADING](#shading)
* [Other resources](#other)

## Description <a name="description"></a>
*(very soon)*  

[Up to table of contents](#table)  

## What is Ray-casting? <a name="whatis"></a>
Ray-casting это метод, который преобразует ограниченную форму данных (очень упрощенную карту или план этажа) в 3D-проекцию, прослеживая лучи из точки обзора в объем просмотра (Ламот 942). Например, лучевая отливка преобразует что-то вроде A в B на рисунке 1.  
![](https://github.com/markveligod/cub3d/raw/master/img/2.gif)  ![](https://github.com/markveligod/cub3d/raw/master/img/1.gif) 

Заметьте, что это не единственное применение Ray-casting. Ray-casting также может быть использована для визуализации карты местности, например, на Рис.2 (ниже). Важно помнить, что Ray-casting прослеживает лучи от глаза зрителя к объектам.  
![](https://github.com/markveligod/cub3d/raw/master/img/3.jpg) ![](https://github.com/markveligod/cub3d/raw/master/img/4.jpg)  
  
[Up to table of contents](#table)  

## RAY-CASTING AND/VS RAY-TRACING <a name="casandtra"></a>
ray-tracing определяет видимость поверхностей, прослеживая воображаемые лучи света от глаза зрителя до объекта в сцене. 
Из обоих определений следует, что излучение и трассировка лучей - это одно и то же. Действительно, в некоторых книгах оба термина используются взаимозаменяемо. Однако с точки зрения игровых программистов лучевое литье рассматривается как особая реализация (подкласс) лучевой трассировки.

Это различие потому, что в целом, ray-casting быстрее, чем ray-tracing. При ray-casting используется некоторое геометрическое ограничение для ускорения процесса рендеринга. Например: стены всегда перпендикулярны полу (вы можете увидеть это в таких играх, как Doom или Wolfenstein 3D). Если бы не было таких ограничений, то ray-casting было бы неосуществимо. Мы не хотели бы, например, создавать лучом произвольные сплайны, потому что трудно найти геометрические ограничения на такие формы.

Таблица представляет собой общее сравнение между ray-casting и ray-tracing. Главное, что нужно помнить, - это то, что существует “меньшее количество лучей”, которые можно проследить при ray-casting из-за некоторых геометрических ограничений. Или, можно также сказать, что ray-casting - это специальная реализация трассировки лучей.

### TABLE: A COMPARISON BETWEEN RAY-CASTING AND RAY-TRACING (GAME PROGRAMMERS/GAME DEVELOPERS PERSPECTIVE)  
| RAY-CASTING | RAY-TRACING |
|:-----------:|:-----------:|
| **Принцип:** лучи отбрасываются и прослеживаются в группах, основанных на некоторых геометрических ограничениях. Например: при разрешении дисплея 320×200 луч-заклинатель отслеживает только 320 лучей (число 320 исходит из того факта, что дисплей имеет разрешение 320 горизонтальных пикселей, следовательно, 320 вертикальных столбцов). | **Принцип:** каждый луч прослеживается отдельно, так что каждая точка (обычно пиксель) на дисплее прослеживается одним лучом. Например: при разрешении дисплея 320×200 луч-трассировщик должен отслеживать 320×200 (64 000) лучей. (Это примерно в 200 раз медленнее, чем Ray-casting.) |
| **Формула:** в большинстве случаев неточна. | **Формула:** в большинстве случаев точная. |
| **Скорость:** очень быстро по сравнению с трассировкой лучей; подходит для процесса в реальном времени. | **Скорость:** медленная; неподходящая для процесса в реальном времени (по крайней мере, пока мы не получили машину с частотой 500 ГГц). |  
| **Качество:** полученное изображение не очень реалистично. Часто они бывают блочными | **Качество:** полученное изображение очень реалистично – иногда даже слишком реалистично |
| **Мир:** ограничен одним или несколькими геометрическими ограничениями (простыми геометрическими фигурами). | **Мир:** почти любая форма может быть визуализирована. |
| **Хранение:** небольшое. Визуализированные изображения не сохраняются на диске. Обычно сохраняется только карта, а соответствующие изображения генерируются на лету. | **Хранение:** визуализированные изображения хранятся на диске и загружаются при необходимости. В настоящее время ни одно оборудование не работает достаточно быстро для рендеринга на лету. |
| **Примеры:** Wolfenstein 3D (iD Software), Shadow Caster (Raven), Arena (Bethesda), Doom (iD Software), Dark Forces (LucasArts). | **Примеры:** 7th Guest (Trilobyte), Critical Path (Mechadeus), 11th Hour (Trilobyte), Myst (Cyan), Cyberia (Xatrix). |
| ![](https://github.com/markveligod/cub3d/raw/master/img/5.jpg)  | ![](https://github.com/markveligod/cub3d/raw/master/img/6.jpg)  |
  
[Up to table of contents](#table)  
## LIMITATIONS OF RAY-CASTING <a name="limit"></a>
Ray-casting происходит быстро, потому что оно использует некоторые геометрические ограничения. В большинстве случаев стены всегда находятся под углом 90 градусов к полу. (Обратите внимание, что мы говорим не об угле между стенами и другими стенами, а об угле между стенами и полом.)

Таким образом, ограничение, которое почти существует в игре по отбрасыванию лучей, заключается в том, что точка обзора не может быть повернута вдоль оси Z. Если это будет разрешено, то стены могут быть наклонены, и преимущество рисования в вертикальных срезах будет потеряно. Эта неспособность вращаться вдоль оси Z является одной из причин того, что среда лучевого литья не рассматривается как истинная трехмерная среда.
![](https://github.com/markveligod/cub3d/raw/master/img/7.jpg)
  
[Up to table of contents](#table)  
## RAY-CASTING STEP 1: CREATING A WORLD  <a name="step1"></a>
Чтобы проиллюстрировать процесс Ray-casting, мы создадим лабиринтный мир, который имеет следующие геометрические ограничения:

1. Стены всегда находятся под углом 90° к полу.
2. Стены сделаны из кубиков, которые имеют одинаковый размер.
3. Пол всегда ровный.
Для наших целей каждый куб будет иметь размер 64x64x64 единиц. (Выбор 64 является произвольным, но будет полезно выбрать число, кратное 2; потому что мы можем выполнить некоторые арифметические операции сдвига над таким числом (операции сдвига быстрее, чем умножение или деление). Чем больше размер куба, тем более блочным будет выглядеть мир, но меньший куб сделает рендеринг медленнее.)
![](https://github.com/markveligod/cub3d/raw/master/img/8.jpg)  

Прежде чем продолжить, мы определим нашу систему координат так, чтобы не было путаницы. Система координат, которую мы используем, проиллюстрирована  

![](https://github.com/markveligod/cub3d/raw/master/img/9.gif)

*Примечание:* любой вид декартовой системы координат будет работать так же хорошо. Однако вы должны быть последовательны (не используйте систему координат сверху вниз для одной вещи, а затем используйте координату кнопки вверх для других).
  
[Up to table of contents](#table)  
## RAY-CASTING STEP 2: DEFINING PROJECTION ATTRIBUTES <a name="step2"></a>
Теперь, когда у нас есть мир, нам нужно определить некоторые атрибуты, прежде чем мы сможем проецировать и визуализировать мир. В частности, нам необходимо знать эти атрибуты:

1. Высота игрока / зрителя, поле зрения игрока (FOV) и положение игрока.
2. Размерность проекционной плоскости.
3. Связь между игроком и плоскостью проекции.
Игрок должен уметь видеть то, что находится перед ним. Для этого нам нужно будет определить поле зрения (FOV). FOV определяет, насколько широко игрок видит мир перед собой (см. рис. 8). Большинство людей имеют FOV 90 градусов или больше. Однако FOV с таким углом зрения не очень хорошо смотрится на экране. Поэтому мы определяем FOV как 60 градусов с помощью проб и экспериментов (о том, насколько хорошо он выглядит на экране). Высота игрока определяется как 32 единицы, потому что это разумное предположение, учитывая, что стены (кубики) имеют высоту 64 единицы.  
![](https://github.com/markveligod/cub3d/raw/master/img/10.gif) 

Чтобы поместить игрока в мир, нам нужно определить координаты игрока X, координаты игрока Y и угол, под которым он находится. Эти три атрибута формируют “точку зрения " игрока.

Предположим, что игрок помещен где-то посередине координатной сетки (1,2) под углом обзора 45 градусов относительно окружающего мира, тогда точка зрения игрока и FOV . (Одна сетка состоит из 64 х 64 единиц. Таким образом, мы также можем сказать, что игрок находится в единичной координате (96,160)).  
![](https://github.com/markveligod/cub3d/raw/master/img/11.jpg)  
Нам нужно определить проекционную плоскость, чтобы мы могли проецировать то, что видит игрок, в проекционную плоскость. Проекционная плоскость шириной 320 единиц и высотой 200 единиц является хорошим выбором, так как это разрешение большинства видеокарт VGA. (Разрешение видео обычно указывается в пикселях, поэтому считайте, что 1 пиксель равен 1 единице.)
Когда точка зрения игрока проецируется в проекционную плоскость, мир должен выглядеть как сцена.  
![](https://github.com/markveligod/cub3d/raw/master/img/12.jpg)  
Зная поле зрения (FOV) и размер плоскости проекции, мы можем рассчитать угол между последующими лучами и расстояние между игроком и плоскостью проекции. Эти шаги проиллюстрированы (многие книги определяют эти последние два значения произвольно, не сообщая читателю, откуда они берутся, вот обоснование.)  
![](https://github.com/markveligod/cub3d/raw/master/img/13.jpg)  
Вот что мы можем вычислить (большинство из них-математика на уровне средней школы, я рекомендую освежить в памяти тригонометрию / теорему Пифагора, если вы не понимаете):  
![](https://github.com/markveligod/cub3d/raw/master/img/14.gif) ![](https://github.com/markveligod/cub3d/raw/master/img/15.gif)  
Так что теперь мы знаем:

Размер проекционной плоскости = 320 х 200 единиц  
Центр проекционной плоскости = (160,100)  
Расстояние до плоскости проекции = 277 единиц  
Угол между последующими лучами = 60/320 градусов  
(Иногда мы будем называть “угол между последующими лучами " как "угол между последующими столбцами"."Позже этот угол будет использоваться для петель от колонки к колонке. Расстояние между игроком и плоскостью проекции будет использоваться для масштабирования.)  
  
[Up to table of contents](#table)  
## RAY-CASTING STEP 3: FINDING WALLS  <a name="step3"></a>
Стену можно рассматривать как совокупность 320 вертикальных линий (или 320 кусочков стены).
![](https://github.com/markveligod/cub3d/raw/master/img/16.gif)  
Это именно та форма геометрических ограничений, которая будет пригодна для Ray-casting. Вместо того чтобы прослеживать луч для каждого пикселя на экране, мы можем проследить только для каждого вертикального столбца экрана. Луч в крайнем левом углу FOV будет проецироваться на столбец 0 плоскости проекции, а самый правый луч будет проецироваться на столбец 319 плоскости проекции.  
![](https://github.com/markveligod/cub3d/raw/master/img/17.jpg)  
Поэтому, чтобы визуализировать такую сцену, мы можем просто проследить 320 лучей, начиная слева направо. Это можно сделать в цикле. Ниже приведены примеры этих шагов:

* Исходя из угла обзора, вычтите 30 градусов (половина FOV).
* Начиная со столбца 0:  
  
  A) Бросьте луч. (Термин "актерский состав" немного сбивает с толку. Представьте себе игрока в роли волшебника, который может "бросать" лучи вместо заклинаний. Луч - это просто "воображаемая" линия, идущая от игрока.)  
  
  B) Проследите за лучом, пока он не упрется в стену.  
* Запишите расстояние до стены (расстояние равно длине луча).
* Добавьте приращение угла так, чтобы луч двигался вправо (мы знаем, что значение приращения угла равно 60/320 градусам).
* Повторяйте шаги 2 и 3 для каждой последующей колонки, пока не будут отброшены все 320 лучей.
Хитрость шага 2 заключается в том,что вместо проверки каждого пикселя нам нужно только проверить каждую сетку. Это происходит потому, что стена может появиться только на границе сетки. Рассмотрим прослеживаемый луч, как показано на рис. 14. Чтобы проверить, попал ли этот луч в стену или нет, достаточно проверить точки пересечения сетки в точках A, B, C, D, E и F.  
![](https://github.com/markveligod/cub3d/raw/master/img/18.gif)  
Чтобы найти стены, нам нужно проверить все точки пересечения сетки, с которыми сталкивается Луч; и посмотреть, есть ли стена на сетке или нет. Лучше всего проверять горизонтальные и вертикальные пересечения отдельно. Когда есть стена на вертикальном или горизонтальном пересечении, проверка останавливается. Затем сравнивается расстояние до обеих точек пересечения и выбирается более близкое расстояние.  
![](https://github.com/markveligod/cub3d/raw/master/img/19.gif)  
Этапы нахождения пересечений с горизонтальными линиями сетки:

* Найдите координату первого пересечения (точка а в данном примере).
* Найду Ya. (Примечание: Ya-это просто высота сетки; однако, если луч направлен вверх, Ya будет отрицательным, если луч направлен вниз, Ya будет положительным.)
* Найдите Xa, используя приведенное выше уравнение.
* Проверьте сетку в точке пересечения. Если на сетке есть стена, остановитесь и рассчитайте расстояние.
* Если стены нет, протяните ее до следующей точки пересечения. Обратите внимание, что координата следующей точки пересечения-назовем ее (Xnew, Ynew) - это Xnew=Xold+X a, а Ynew=YOld+Ya.
В качестве примера ниже приводится то, как вы можете получить точку а:  
```
*Примечание:* помните, что Декартовая координата увеличивается вниз, и любые дробные значения будут округлены вниз.

= = = = = = Нахождение горизонтального пересечения ======
1. Нахождение координаты точки A.
Если луч направлен вверх
`A.y = rounded_down(Py/64) * (64) - 1;`
Если луч направлен вниз
`A.y = rounded_down(Py/64) * (64) + 64;`

(На картинке луч направлен вверх, поэтому мы используем первую формулу)  

A. y=rounded_down(224/64) * (64) - 1 = 191;
Теперь на этом этапе мы можем узнать сетку координаты y.
Однако мы должны решить, является ли A частью блок над линией, или блок под линией.
Здесь мы решили сделать часть блока
выше линии, вот почему мы вычитаем 1 из A. y.
Таким образом, координата сетки A. y равна 191/64 = 2;

A. x = Px + (Py-A. y)/tan (Альфа);
На рисунке (предположим, что Альфа равна 60 градусам),
A. x=96 + (224-191) / tan (60) = около 115;
Координата сетки A. x равна 115/64 = 1;

Таким образом, A находится в сетке (1,2), и мы можем проверить
есть ли на этой решетке стена?
Там нет стены на (1,2), так что луч будет
продлено до с.

2. Найти Ya
Если луч направлен вверх
Yа=-64;
Если луч направлен вниз
Ya=64;

3. Найти Хa
Xa = 64 / tan(60) = 36;

4. Мы можем получить координату с следующим образом:
C. x=A. x+Xa = 115 + 36 = 151;
C. y=A. y+Ya = 191-64 = 127;
Преобразуйте это в координату сетки с помощью
деление каждого компонента на 64.
Результат таков
C. x = 151/64 = 2 (координата сетки),
C. y = 127/64 = 1 (координата сетки)
Таким образом, координата сетки C равна (2, 1).
(*Примечание программиста C:* помните, что мы всегда округляем вниз, это особенно верно, так как вы можете использовать правый сдвиг на 8, чтобы разделить на 64).  

5. Проверяется сетка (2,1).
Опять же, нет никакой стены, поэтому луч расширяется к a.  

6. Мы можем получить координату D следующим образом:
D. x=C. x+Xa = 151+36 = 187;
D. y=C. y+Ya = 127-64 = 63;
Преобразуйте это в координату сетки с помощью
деление каждого компонента на 64.
Результат таков
D. x = 187/64 = 2 (координата сетки),
D. y = 63/64 = 0 (координата сетки)
Таким образом, координата сетки D равна (2, 0).

6. Проверяется сетка (2,0).
Там есть стена, так что процесс остановится.
```  
*(Примечание программиста: вы можете видеть, что как только у нас есть значение Xa и Ya, процесс очень прост. Мы просто продолжаем добавлять старое значение с помощью Xa и Ya и выполняем операцию сдвига, чтобы узнать сеточную координату следующей точки, пораженной лучом.)*  
![](https://github.com/markveligod/cub3d/raw/master/img/20.gif)  
Этапы нахождения пересечений с вертикальными линиями сетки:

* Найдите координату первого пересечения (точка B в данном примере).
* Луч направлен прямо на изображение, поэтому B. x = rounded_down(Px/64) * (64) + 64.
* Если бы луч был обращен влево B. x = rounded_down(Px/64) * (64) – 1.
    A.y = Py + (Px-A. x)*tan (Альфа);
* Найти Хa. (*Примечание:* Xa - это только ширина сетки; однако, если луч направлен вправо, Xa будет положительным, если луч направлен влево, Ya будет отрицательным.)
* Найдите Ya, используя приведенное выше уравнение.
* Проверьте сетку в точке пересечения. Если на сетке есть стена, остановитесь и рассчитайте расстояние.
* Если стены нет, протяните ее до следующей точки пересечения. Обратите внимание, что координата следующей точки пересечения-назовем ее (Xnew, Ynew) - это просто Xnew=Xold+Xa, а Ynew=YOld+Ya.
* На рисунке, во-первых, луч попадает в точку B. сетка (2,2) проверяется. Там нет стены на (2,2), поэтому луч расширяется до E. сетка (3,0) проверена. Там есть стена, поэтому мы останавливаемся и вычисляем расстояние.

В этом примере точка D находится ближе, чем E. Таким образом, будет нарисован срез стены в точке D (а не E).  
  
[Up to table of contents](#table)  
## RAY-CASTING STEP 4: FINDING DISTANCE TO WALLS  <a name="step4"></a>
Существует несколько способов найти расстояние от точки обзора (игрока) до среза стены. Они проиллюстрированы ниже.  
![](https://github.com/markveligod/cub3d/raw/master/img/21.gif)  
Функции синуса или Косинуса дешевле реализовать, потому что они могут быть предварительно вычислены и помещены в таблицы. Это может быть сделано потому, что Альфа (POV игрока) должна быть от 0 до 360 градусов, поэтому количество возможностей ограничено (метод квадратного корня имеет практически неограниченные возможные значения для x и y).

Прежде чем рисовать стену, есть одна проблема, о которой необходимо позаботиться. Эта проблема известна как "эффект аквариума"."Эффект аквариума происходит потому, что реализация лучевого литья смешивает полярную координату и декартову координату вместе. Поэтому использование приведенной выше формулы на срезах стен, которые не находятся непосредственно перед зрителем, даст большее расстояние. Это не то, что мы хотим, потому что это вызовет искажение просмотра, как показано ниже.  
![](https://github.com/markveligod/cub3d/raw/master/img/22.gif)  
![](https://github.com/markveligod/cub3d/raw/master/img/23.gif)  
Таким образом, чтобы устранить искажение обзора, результирующее расстояние, полученное из уравнений на рис, должно быть умножено на cos(BETA); где BETA-угол луча, который отбрасывается относительно угла обзора. На рисунке выше угол обзора (Альфа) равен 90 градусам, потому что игрок смотрит прямо вверх. Поскольку у нас есть поле зрения 60 градусов, бета равна 30 градусам для самого левого луча и -30 градусам для самого правого луча.  
  
[Up to table of contents](#table)  
## RAY-CASTING STEP 5: DRAWING WALLS  <a name="step5"></a>
На предыдущих этапах было отброшено 320 лучей, и когда каждый луч попадает на стену, вычисляется расстояние до этой стены. Зная расстояние, срез стены можно затем спроецировать на проекционную плоскость. Для этого нужно найти высоту проектируемого среза стены. Оказывается, это можно сделать с помощью простой формулы:  
```
                           Фактическая Высота Среза  
Проецируемая высота среза= --------------------- * расстояние до плоскости проекции  
                            Расстояние до среза
```  
![](https://github.com/markveligod/cub3d/raw/master/img/24.gif)  
Наш мир состоит из кубов, где размер каждого куба составляет 64х64х64 единицы, поэтому высота стены составляет 64 единицы. Мы также уже знаем расстояние игрока до плоскости проекции (которое равно 277). Таким образом, уравнение может быть упрощено до:
Проекционная высота среза = 64 / расстояние до среза * 277

В реальной реализации можно рассмотреть несколько моментов:

Например, 64/277 может быть предварительно вычислено, так как это будет постоянное значение. После того, как это будет рассчитано, срез стены может быть нарисован на экране. Это можно сделать, просто проведя вертикальную линию по соответствующему столбцу на плоскости проекции (экране).

Помните, откуда взялся номер 277? Это число на самом деле может быть немного отклонено, не вызывая никакого огромного воздействия. На самом деле, это сэкономит время, чтобы использовать значение 255, потому что программист может использовать оператор сдвига для экономии вычислительного времени (сдвиг вправо на 3 для умножения, сдвиг влево для деления).

Например, предположим, что Луч в колонке 200 попадает в срез стены на расстоянии 330 единиц. Проекция среза будет такой 64 / 330 * 277 = 54 (округлено вверх).
Так как центр плоскости проекции определен равным 100. В этой точке должна появиться середина среза стены. Следовательно, верхняя позиция, в которой должен быть нарисован срез стены, равна 100-27=73. (где 27 - это половина от 54). Наконец, проекция среза будет выглядеть примерно так же, как на следующем рисунке.  
![](https://github.com/markveligod/cub3d/raw/master/img/25.gif)  
  
[Up to table of contents](#table)  
## TEXTURE MAPPED WALLS  <a name="texture"></a>
Чтобы сделать стены более привлекательными, их можно нарисовать текстурой (растровым изображением), используя технику, известную как отображение текстур. (Отображение текстур в общем случае относится к технике нанесения растрового изображения / текстуры на поверхность.) Для кубического мира мы используем растровые изображения размером 64 на 64 пикселя. Этот размер выбран потому, что 64 на 64 - это также размер граней куба, которые мы используем в нашем мире. Можно использовать растровые изображения разного размера, но использование одного и того же размера упрощает процесс отображения текстур.

Если мы хотим отобразить текстуру на произвольный полигон, то процесс отображения текстур будет сложным. К счастью, в созданном нами мире лучевого литья отображение текстур - это всего лишь вопрос масштабирования фрагмента (столбца) растрового изображения.  
![](https://github.com/markveligod/cub3d/raw/master/img/26.jpg)  
Когда луч ищет пересечение стены, смещение (положение луча относительно сетки) может быть легко найдено. Затем это смещение можно использовать для определения того, какой столбец растрового изображения должен быть нарисован как срез стены. На следующем рисунке показан процесс нахождения смещения.  
![](https://github.com/markveligod/cub3d/raw/master/img/27.gif)  
  
[Up to table of contents](#table)  
## DRAWING FLOORS  <a name="floors"></a>
Чтобы нарисовать полы, мы можем выполнить floor-casting (floor-casting относится к технике рендеринга полов). Обратите внимание, однако, что было бы расточительно выполнять floor-casting без отображения текстуры или затенения. Другими словами, если пол не должен быть текстурирован или затенен (затенение будет изучено позже), то мы можем просто покрасить пол в сплошной цвет, и все готово. Имея это в виду, давайте рассмотрим, что требуется для выполнения напольного литья.

Существует несколько способов сделать floor-casting. Однако все они используют одну и ту же технику. Эта техника объясняется ниже.

1. Найдите перекресток с полом.
2. Определите мировую координату пола, который был пересечен.
3. Рассчитайте расстояние между игроком и пересечением пола.
4. Спроецируйте пересечение пола на проекционную плоскость.
Обратите внимание, что не обязательно рисовать все этажи. Мы должны рисовать только те полы, которые не покрыты стенами. По этой причине мы должны начать casting с нижней части кусочков стены. Начиная с нижней части срезов, мы затем сканируем каждый пиксель на плоскости проекции в направлении вниз (т. е. отбрасываем лучи впоследствии в направлении вниз). Однако на этот раз вместо того, чтобы искать пересечение со стенами, луч ищет пересечение с полом.  
![](https://github.com/markveligod/cub3d/raw/master/img/28.gif)  
*Помните, что нам не нужно бросать за пределы проекционной плоскости. (То есть: бросок от нижней части среза стены, ряд за рядом в направлении вниз; остановка, когда достигается нижняя часть плоскости проекции.)*  
![](https://github.com/markveligod/cub3d/raw/master/img/29.gif)  
Чтобы повторить, взгляните на иллюстрацию во время чтения этих шагов:

* Начните с нижней части среза стены.

    A. Возьмите положение пикселя (у вас есть это значение, когда вы делали отливку стены).  
    B. Нарисуйте линию (луч) ОТ ПИКСЕЛЯ ДО глаза зрителя.  
    C. Вытягивает линию так, чтобы она пересекала пол.  
    D. Точка, где линия “пересекает " пол, - это точка на карте текстуры, в которую попадает луч.  
    E. Возьмите значение пикселя этой точки На карте текстуры (см. Следующий рисунок, чтобы увидеть, как это можно сделать) и нарисуйте его на экране.  
* Повторяйте упражнение A-E до тех пор, пока не будет достигнута нижняя часть экрана.  
![](https://github.com/markveligod/cub3d/raw/master/img/30.gif)  
  
[Up to table of contents](#table)  
## DRAWING CEILINGS  <a name="ceilings"></a>
Чтобы нарисовать потолок, процесс floor-casting может быть обращен вспять. Вместо того чтобы прослеживать лучи от нижней части среза стены в направлении вниз, проследите луч от верхней части стены в направлении вверх. Это на самом деле довольно просто, как только теория, лежащая в основе floor-casting, была понята.  
![](https://github.com/markveligod/cub3d/raw/master/img/31.gif)  
Позже мы объясним, как имитировать иллюзию взгляда вверх, взгляда вниз, полета и приседания. Если программист не хочет их имитировать, то можно нарисовать пол и потолок одновременно. Это происходит потому, что расстояние от глаз игрока до пола и потолка равно/симметрично. (Полы и потолки симметричны, так как глаза игрока находятся точно посередине между этажами и потолками.)  
  
[Up to table of contents](#table)  
## VARIABLE HEIGHT WALLS  <a name="walls"></a>
До сих пор все стены в нашем мире имеют одинаковую высоту. С некоторыми нововведениями мы действительно можем использовать стены разной высоты. Это делает мир более интересным, как показано на следующем рисунке.  
![](https://github.com/markveligod/cub3d/raw/master/img/32.jpg)  
Самый простой способ концептуализировать стены переменной высоты-это рассматривать стены как полы. То есть представьте себе стены как приподнятые полы. Нам понадобится массив, чтобы удерживать высоту каждой сетки пола, чтобы сделать эту работу. Основной метод визуализации сцены заключается в следующем:  
  1. Начните с самого левого столбца плоскости проекции.  
  2. Найдите высоту пола, на котором в данный момент находится игрок. (Назовем это CURRENT_HEIGHT.)  
  3. Бросьте Луч и проверьте перекрестки, как и раньше.  
  4. Если луч попадает на пол, который имеет другую высоту, чем CURRENT_HEIGHT, то этот пол либо поднимается, либо опускается. (Приподнятый пол - это просто стена.)  
  5. Если ее поднять, то она будет видна. Спроецируйте его и визуализируйте. (Рисунок 30 ниже иллюстрирует математику, стоящую за этим.)  
  6. Если он потоплен, то нам не нужно проецировать его, потому что он не будет виден.  
  7. Нарисуйте пол от точки, где происходит изменение высоты, до точки, на которую проецируется верхняя часть последнего куска стены. (Первоначально верхняя часть последнего среза стены будет нижней частью плоскости проекции.)  
  8. Повторяйте упражнение до тех пор, пока луч не пройдет границу карты мира.  
  9. Повторите шаги 2-8 для всех последующих столбцов.  
Чтобы прояснить этот процесс, рассмотрим процесс рендеринга сцены.  
![](https://github.com/markveligod/cub3d/raw/master/img/33.jpg)  
Начните с трассировки луча, который попадает в точку А (самый нижний ряд плоскости проекции). Когда луч перемещается вдоль плоскости проекции в направлении вверх, стена в точке B ударяется, и получается срез BC. Зная, что нет никакого изменения высоты от А до в, пол от точки А до В рисуется. Затем луч расширяется. Он обнаруживает изменение высоты в точке D. Поэтому рисуется срез DE. Зная, что нет никакого изменения высоты от точки С до D, пол от точки С до D рисуется. Затем луч снова расширяется. В точке F, на краю карты будет достигнута. Поскольку больше не может быть никаких изменений высоты, пол из точки F в точку E рисуется, и процесс повторяется до тех пор, пока не будет отрисован весь экран.  
Основным недостатком использования стен переменной высоты является то, что процесс рендеринга будет значительно медленнее. Это происходит потому, что лучи больше не останавливаются, когда ударяется ближайшая стена. Один из способов ускорить это-установить расстояние видимости и просто игнорировать все, что находится за этим расстоянием.  
![](https://github.com/markveligod/cub3d/raw/master/img/34.gif)  
  
[Up to table of contents](#table)  
## HORIZONTAL MOTION  <a name="hor"></a>
Игрок должен уметь двигаться по крайней мере тремя способами: вперед, назад и поворачиваться. Положение игрока определяется координатами и углом обзора. Чтобы разрешить движение, необходимы еще два атрибута. Это скорость движения игрока и скорость его поворота. Скорость движения игрока определяет, сколько единиц игрок должен двигаться, когда он движется вперед или назад. Скорость поворота игрока (измеренная в угле) определяет, сколько углов нужно добавить или вычесть, когда игрок поворачивается. Мы обсудим каждый из них, как мы используем эти атрибуты, чтобы позволить движение.  

**А. движение вперед и назад.**  
Мы определяем скорость движения игрока как 10 единиц. (Как правило, это может быть любое число, но чем больше число, тем менее плавным будет казаться движение.) Процесс нахождения смещений x и y проиллюстрирован ниже. Если игрок движется вперед, мы добавляем XDisplacement к координате X текущего игрока; и добавляем Ydisplacement к координате y текущего игрока. Если игрок движется назад, мы вычитаем XDisplacement из координаты X текущего игрока; и вычитаем Ydisplacement из координаты Y текущего игрока. (Всегда проверяйте границы мира / стены, чтобы игрок не выходил за пределы карты или не проходил через стену.)  
![](https://github.com/markveligod/cub3d/raw/master/img/35.gif)  
**Б. Поворот.**  
Процесс токарной обработки очень прост в реализации. Все, что нам нужно сделать, - это добавить или вычесть приращение угла (aI) к текущему углу обзора игрока (оборачиваться всякий раз, когда ход переходит в полный круг). Опять же, большее увеличение угла приведет к тому, что движение будет выглядеть менее плавным.  
![](https://github.com/markveligod/cub3d/raw/master/img/36.gif)  
  
[Up to table of contents](#table)  
## VERTICAL MOTION: LOOKING UP AND DOWN  <a name="ver"></a>
Можно имитировать иллюзию смотрения вверх и вниз,а также полет и приседание на излучающей среде. Однако обратите внимание ,что - и это очень важно-трюк, который будет объяснен здесь, не всегда следует правильным теориям трехмерной проекции. Т. е.: это трюки, они не являются правильным способом сделать "реалистичную" симуляцию.

**A: глядя вверх и вниз.**  
Напомним, что проекционная плоскость имеет высоту 200 единиц. И до этого момента мы всегда устанавливаем вертикальный центр плоскости проекции точно посередине (то есть в точке y=100). Таким образом, средняя точка любого среза стены будет нарисована в точке проекции y=100. Оказывается, что эффект взгляда вверх или вниз можно смоделировать, просто изменив это значение.  
То есть, чтобы имитировать взгляд вверх, вместо того чтобы поместить центр вертикального среза в y=100, мы помещаем его в точку, где y>100 (это похоже на перемещение плоскости проекции вверх).  
Аналогично, чтобы имитировать взгляд вниз, вместо того чтобы поместить центр вертикального среза на y=100, мы помещаем его в точку, где y<100 (это похоже на перемещение плоскости проекции вниз).  
И почему этот трюк вообще работает? Надеюсь, что следующие иллюстрации объясняют это.  
![](https://github.com/markveligod/cub3d/raw/master/img/37.gif)  
![](https://github.com/markveligod/cub3d/raw/master/img/38.gif)  
![](https://github.com/markveligod/cub3d/raw/master/img/39.gif)  
*Если вы в замешательстве, представьте, что держите зеркало со стеной позади себя, стоя прямо. Когда зеркало перемещается вверх или вниз, показывается другая часть стены. Зеркало - это проекционная плоскость. (Представьте себе это на мгновение, прежде чем продолжить.)*  

**Б. полет и приседание.**  
Напомним, что рост игрока устанавливается равным 32 единицам. Это означает, что глаза игрока (представьте себе, что глаза игрока находятся точно на макушке головы игрока) смотрят прямо на стены в точке 32. Поскольку 32 - это одна половина высоты стен, то при высоте игрока 32 глаза игрока находятся на полпути между полом и потолком (см. Следующий рисунок).  
А что, если мы изменим это значение? Удивительно (а может быть и нет), что стены будут смещаться либо вверх, либо вниз в зависимости от того, увеличивается или уменьшается рост игрока.  
Таким образом, чтобы сделать игрока таким, как будто он летит (или прыгает), мы можем просто увеличить высоту игрока. Точно так же, чтобы сделать игрока таким, как будто он сидит на корточках, мы можем уменьшить рост игрока. Высота не должна быть меньше 0 или больше высоты стен, потому что это заставит игрока перелезть через потолок или погрузиться в пол.  
На следующем рисунке показано, почему этот метод работает.  
![](https://github.com/markveligod/cub3d/raw/master/img/40.jpg)  
![](https://github.com/markveligod/cub3d/raw/master/img/41.gif)  
![](https://github.com/markveligod/cub3d/raw/master/img/42.gif)  
Если вы запутались, мы снова используем зеркальный метод, чтобы прояснить, как это работает. Представьте себе, что вы стоите прямо, держа зеркало в маленькой комнате. Встаньте лицом к стене. Расположите зеркало так, чтобы оно было перед глазами (т. е. вам не нужно поворачивать голову, чтобы увидеть зеркало). А теперь представьте себе, что произойдет, если вы присядете на корточки и посмотрите, что находится в зеркале. В зеркале вы должны видеть другую часть стены и большую площадь пола... как 2-е изображение на этой странице .... надеюсь, у тебя есть идея.  
Зеркало-это проекционная плоскость, а положение глаз-это высота игрока.  
Есть один противоположный интуитивный аспект этого метода вертикального движения, который заключается в следующем: проекционная плоскость всегда должна быть перпендикулярна глазам игрока. (То есть плоскость проекции всегда должна быть параллельна стенам – они никак не могут быть перекошены.) Лучший способ концептуализировать это-представить себе человека, "целящегося" через объектив камеры. Человек всегда целится вперед под углом 90 градусов, даже когда он сидит на корточках или стоит на столе.  
Причина этого заключается в том, что при использовании этого метода мы не можем наклонить плоскость проекции, как на следующем рисунке; потому что если мы повернем плоскость проекции, чтобы следовать “нормальному” направлению глаза, то стены будут наклонены (больше не параллельны плоскости проекции); и процесс визуализации должен тогда учитывать это. Это означает, что потребуется более сложный расчет, и процесс рендеринга станет ужасно медленным.  
![](https://github.com/markveligod/cub3d/raw/master/img/43.gif)  
**В. комбинированные эффекты.**  
Эффекты, описанные выше, могут быть объединены для создания еще более интересных движений, таких как показано ниже.  
![](https://github.com/markveligod/cub3d/raw/master/img/44.gif)  
![](https://github.com/markveligod/cub3d/raw/master/img/45.gif)  
![](https://github.com/markveligod/cub3d/raw/master/img/46.jpg)  
  
[Up to table of contents](#table)  
## SHADING  <a name="shading"></a>
Когда объект находится дальше от зрителя, он должен казаться менее / более ярким. Для достижения этой цели необходим эффект затенения. Но Сначала нам нужно узнать, как представлены цвета.  
Стандартные 256 цветовые регистры режима VGA содержат три числа от 0 до 63 для каждого цвета в палитре, которые называются значениями RGB (RedGreenBlue). Например, полный красный цвет имеет компоненты RGB (63,0,0); полный зеленый имеет (0,63,0); и полный синий имеет (0,0,63). Цвет, такой как полный желтый, может быть получен путем смешивания полного красного и полного зеленого цветов, так что (63,63,0) будет желтым.  
Чтобы изменить яркость красного, зеленого или синего компонента цвета, число, представляющее цветовой компонент, должно быть увеличено или уменьшено. Например, чтобы уменьшить интенсивность цвета, имеющего компоненты RGB (50,10,10), наполовину, умножьте каждый компонент на 0,5. Полученный цвет будет равен (25,5,5).  
Это довольно просто, но как мы узнаем, какую интенсивность использовать на каком расстоянии? Первый вариант-использовать точную формулу интенсивности света, которая выглядит примерно так:  

`Intensity = (kI/(d+do))*(N*L) `  

С точки зрения программиста игр, эта формула слишком сложна и будет ужасно медленной, поэтому мы даже не будем с ней возиться. Наша главная цель будет заключаться в том, чтобы сделать эффект затенения, который выглядит правильно (или, по крайней мере, разумно). Нам не особенно важно, является ли формула, которую мы используем, правильной формулой учебника или нет.  
*(Боковое Примечание.: Что касается игрового программирования, то я склонен согласиться с этим принципом:
лучше иметь что-то быстрое и кажущееся-резонансно-правильным; то есть иметь что-то точно-правильное, но медленное.)*  
Поэтому вместо этого используется следующая формула.  

`Интенсивность = Интенсивность Объекта / Расстояние * Множитель`  

Здесь интенсивность объекта-это интенсивность, которую программист хочет использовать (она должна быть между 0 и 1). На самом деле это довольно просто концептуально. Это в основном говорит о том, что по мере удаления объектов интенсивность объекта становится меньше. Множитель-это число, которое предотвращает падение интенсивности до быстрого с расстоянием. Этот расчет все еще может быть дорогостоящим в реальном времени, поэтому можно использовать таблицу расстояний, такую как следующая таблица:  

| Расстояние до объекта | интенсивность |
|:---------------------:|:-------------:|
| От 0 до 500 | 1 |
| От 501 до 1000 | 0,75 |
| От 1001 до 1500 | 0,50 |  

Ray-casting лучей хорошо подходит здесь, потому что, когда мы бросаем луч, мы также получаем расстояние до объекта, который будет визуализирован. В реальной реализации мы должны учитывать также количество доступных цветов. Поскольку большинство игр могут использовать только 256 цветов, некоторые акробатические трюки будут необходимы, чтобы убедиться, что палитра содержит правильный цветовой диапазон. Возможным решением для этого является использование алгоритма подбора цветов и отображение результата в таблицу интенсивности. При рендеринге мы просто получаем правильное значение цвета из соответствующей таблицы. (Это довольно быстро, потому что определенный срез стены будет иметь одинаковую интенсивность для всех своих пикселей. Так что нам остается только переключать стол между кусочками стены.)  

| Расстояние до объекта | интенсивность | Индекс Таблицы Сопоставления Палитр |
|:---------------------:|:-------------:|:-----------------------------------:|
| От 0 до 500 | 1 | 1 |
| От 501 до 1000 | 0,75 | 2 |
| От 1001 до 1500 | 0,50 | 3 |
| ... | ... | ... |  

Обычно, когда интенсивность объекта приближается к нулю, объект будет казаться темнее. Однако это не обязательно должно быть всегда так. Мы можем создать интересный эффект, такой как туман или подводный эффект, изменив "целевой цвет".” Например, чтобы создать эффект тумана, мы можем сделать палитру сходящейся к белому цвету.  

| NIGHT EFFECT | FOG EFFECT | OOZE UNDERWATER EFFECT | UNDERSEA EFFECT |
|:------------:|:----------:|:----------------------:|:---------------:|
|![](https://github.com/markveligod/cub3d/raw/master/img/47.jpg)|![](https://github.com/markveligod/cub3d/raw/master/img/48.jpg)|![](https://github.com/markveligod/cub3d/raw/master/img/49.jpg)|![](https://github.com/markveligod/cub3d/raw/master/img/50.jpg)|  

Original link: [click](https://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/)  
  
[Up to table of contents](#table)  

## Other resources <a name="other"></a>  
* [Raycasting](https://lodev.org/cgtutor/raycasting.html)  
* [Minilibx](https://github.com/keuhdall/images_example)  
  
**Author:** *[Mark Veligod](https://github.com/markveligod)* 
