# Cub3d(project 2020)
## Table of contents  

## Description

## What is Ray-casting?
Ray-casting это метод, который преобразует ограниченную форму данных (очень упрощенную карту или план этажа) в 3D-проекцию, прослеживая лучи из точки обзора в объем просмотра (Ламот 942). Например, лучевая отливка преобразует что-то вроде A в B на рисунке 1.  
![](https://github.com/markveligod/cub3d/raw/master/img/2.gif)  ![](https://github.com/markveligod/cub3d/raw/master/img/1.gif) 

Заметьте, что это не единственное применение Ray-casting. Ray-casting также может быть использована для визуализации карты местности, например, на Рис.2 (ниже). Важно помнить, что Ray-casting прослеживает лучи от глаза зрителя к объектам.  
![](https://github.com/markveligod/cub3d/raw/master/img/3.jpg) ![](https://github.com/markveligod/cub3d/raw/master/img/4.jpg) 

## RAY-CASTING AND/VS RAY-TRACING
ray-tracing определяет видимость поверхностей, прослеживая воображаемые лучи света от глаза зрителя до объекта в сцене. 
Из обоих определений следует, что излучение и трассировка лучей - это одно и то же. Действительно, в некоторых книгах оба термина используются взаимозаменяемо. Однако с точки зрения игровых программистов лучевое литье рассматривается как особая реализация (подкласс) лучевой трассировки.

Это различие потому, что в целом, ray-casting быстрее, чем ray-tracing. При ray-casting используется некоторое геометрическое ограничение для ускорения процесса рендеринга. Например: стены всегда перпендикулярны полу (вы можете увидеть это в таких играх, как Doom или Wolfenstein 3D). Если бы не было таких ограничений, то ray-casting было бы неосуществимо. Мы не хотели бы, например, создавать лучом произвольные сплайны, потому что трудно найти геометрические ограничения на такие формы.

Таблица представляет собой общее сравнение между ray-casting и ray-tracing. Главное, что нужно помнить, - это то, что существует “меньшее количество лучей”, которые можно проследить при ray-casting из-за некоторых геометрических ограничений. Или, можно также сказать, что ray-casting - это специальная реализация трассировки лучей.

### TABLE: A COMPARISON BETWEEN RAY-CASTING AND RAY-TRACING (GAME PROGRAMMERS/GAME DEVELOPERS PERSPECTIVE)  
| RAY-CASTING | RAY-TRACING |
|:-----------:|:-----------:|
| **Принцип:** лучи отбрасываются и прослеживаются в группах, основанных на некоторых геометрических ограничениях. Например: при разрешении дисплея 320×200 луч-заклинатель отслеживает только 320 лучей (число 320 исходит из того факта, что дисплей имеет разрешение 320 горизонтальных пикселей, следовательно, 320 вертикальных столбцов). | **Принцип:** каждый луч прослеживается отдельно, так что каждая точка (обычно пиксель) на дисплее прослеживается одним лучом. Например: при разрешении дисплея 320×200 луч-трассировщик должен отслеживать 320×200 (64 000) лучей. (Это примерно в 200 раз медленнее, чем лучевое литье.) |
| **Формула:** в большинстве случаев неточна. | **Формула:** в большинстве случаев точная. |
| **Скорость:** очень быстро по сравнению с трассировкой лучей; подходит для процесса в реальном времени. | **Скорость:** медленная; неподходящая для процесса в реальном времени (по крайней мере, пока мы не получили машину с частотой 500 ГГц). |  
| **Качество:** полученное изображение не очень реалистично. Часто они бывают блочными | **Качество:** полученное изображение очень реалистично – иногда даже слишком реалистично |
| **Мир:** ограничен одним или несколькими геометрическими ограничениями (простыми геометрическими фигурами). | **Мир:** почти любая форма может быть визуализирована. |
| **Хранение:** небольшое. Визуализированные изображения не сохраняются на диске. Обычно сохраняется только карта, а соответствующие изображения генерируются на лету. | **Хранение:** визуализированные изображения хранятся на диске и загружаются при необходимости. В настоящее время ни одно оборудование не работает достаточно быстро для рендеринга на лету. |
| **Примеры:** Wolfenstein 3D (iD Software), Shadow Caster (Raven), Arena (Bethesda), Doom (iD Software), Dark Forces (LucasArts). | **Примеры:** 7th Guest (Trilobyte), Critical Path (Mechadeus), 11th Hour (Trilobyte), Myst (Cyan), Cyberia (Xatrix). |
| ![](https://github.com/markveligod/cub3d/raw/master/img/5.jpg)  | ![](https://github.com/markveligod/cub3d/raw/master/img/6.jpg)  |

## LIMITATIONS OF RAY-CASTING
Ray-casting происходит быстро, потому что оно использует некоторые геометрические ограничения. В большинстве случаев стены всегда находятся под углом 90 градусов к полу. (Обратите внимание, что мы говорим не об угле между стенами и другими стенами, а об угле между стенами и полом.)

Таким образом, ограничение, которое почти существует в игре по отбрасыванию лучей, заключается в том, что точка обзора не может быть повернута вдоль оси Z. Если это будет разрешено, то стены могут быть наклонены, и преимущество рисования в вертикальных срезах будет потеряно. Эта неспособность вращаться вдоль оси Z является одной из причин того, что среда лучевого литья не рассматривается как истинная трехмерная среда.
![](https://github.com/markveligod/cub3d/raw/master/img/7.jpg)

## RAY-CASTING STEP 1: CREATING A WORLD  
Чтобы проиллюстрировать процесс Ray-casting, мы создадим лабиринтный мир, который имеет следующие геометрические ограничения:

1. Стены всегда находятся под углом 90° к полу.
2. Стены сделаны из кубиков, которые имеют одинаковый размер.
3. Пол всегда ровный.
Для наших целей каждый куб будет иметь размер 64x64x64 единиц. (Выбор 64 является произвольным, но будет полезно выбрать число, кратное 2; потому что мы можем выполнить некоторые арифметические операции сдвига над таким числом (операции сдвига быстрее, чем умножение или деление). Чем больше размер куба, тем более блочным будет выглядеть мир, но меньший куб сделает рендеринг медленнее.)
![](https://github.com/markveligod/cub3d/raw/master/img/8.jpg)  

Прежде чем продолжить, мы определим нашу систему координат так, чтобы не было путаницы. Система координат, которую мы используем, проиллюстрирована  

![](https://github.com/markveligod/cub3d/raw/master/img/9.gif)

*Примечание:* любой вид декартовой системы координат будет работать так же хорошо. Однако вы должны быть последовательны (не используйте систему координат сверху вниз для одной вещи, а затем используйте координату кнопки вверх для других).

## RAY-CASTING STEP 2: DEFINING PROJECTION ATTRIBUTES
Теперь, когда у нас есть мир, нам нужно определить некоторые атрибуты, прежде чем мы сможем проецировать и визуализировать мир. В частности, нам необходимо знать эти атрибуты:

1. Высота игрока / зрителя, поле зрения игрока (FOV) и положение игрока.
2. Размерность проекционной плоскости.
3. Связь между игроком и плоскостью проекции.
Игрок должен уметь видеть то, что находится перед ним. Для этого нам нужно будет определить поле зрения (FOV). FOV определяет, насколько широко игрок видит мир перед собой (см. рис. 8). Большинство людей имеют FOV 90 градусов или больше. Однако FOV с таким углом зрения не очень хорошо смотрится на экране. Поэтому мы определяем FOV как 60 градусов с помощью проб и экспериментов (о том, насколько хорошо он выглядит на экране). Высота игрока определяется как 32 единицы, потому что это разумное предположение, учитывая, что стены (кубики) имеют высоту 64 единицы.  
![](https://github.com/markveligod/cub3d/raw/master/img/10.gif) 

Чтобы поместить игрока в мир, нам нужно определить координаты игрока X, координаты игрока Y и угол, под которым он находится. Эти три атрибута формируют “точку зрения " игрока.

Предположим, что игрок помещен где-то посередине координатной сетки (1,2) под углом обзора 45 градусов относительно окружающего мира, тогда точка зрения игрока и FOV . (Одна сетка состоит из 64 х 64 единиц. Таким образом, мы также можем сказать, что игрок находится в единичной координате (96,160)).  
![](https://github.com/markveligod/cub3d/raw/master/img/11.jpg)  
Нам нужно определить проекционную плоскость, чтобы мы могли проецировать то, что видит игрок, в проекционную плоскость. Проекционная плоскость шириной 320 единиц и высотой 200 единиц является хорошим выбором, так как это разрешение большинства видеокарт VGA. (Разрешение видео обычно указывается в пикселях, поэтому считайте, что 1 пиксель равен 1 единице.)
Когда точка зрения игрока проецируется в проекционную плоскость, мир должен выглядеть как сцена.  
![](https://github.com/markveligod/cub3d/raw/master/img/12.jpg)  
Зная поле зрения (FOV) и размер плоскости проекции, мы можем рассчитать угол между последующими лучами и расстояние между игроком и плоскостью проекции. Эти шаги проиллюстрированы (многие книги определяют эти последние два значения произвольно, не сообщая читателю, откуда они берутся, вот обоснование.)  
![](https://github.com/markveligod/cub3d/raw/master/img/13.jpg)  
Вот что мы можем вычислить (большинство из них-математика на уровне средней школы, я рекомендую освежить в памяти тригонометрию / теорему Пифагора, если вы не понимаете):  
![](https://github.com/markveligod/cub3d/raw/master/img/14.gif) ![](https://github.com/markveligod/cub3d/raw/master/img/15.gif)  
Так что теперь мы знаем:

Размер проекционной плоскости = 320 х 200 единиц  
Центр проекционной плоскости = (160,100)  
Расстояние до плоскости проекции = 277 единиц  
Угол между последующими лучами = 60/320 градусов  
(Иногда мы будем называть “угол между последующими лучами " как "угол между последующими столбцами"."Позже этот угол будет использоваться для петель от колонки к колонке. Расстояние между игроком и плоскостью проекции будет использоваться для масштабирования.)  

## RAY-CASTING STEP 3: FINDING WALLS  
Стену можно рассматривать как совокупность 320 вертикальных линий (или 320 кусочков стены).
![](https://github.com/markveligod/cub3d/raw/master/img/16.gif)  
Это именно та форма геометрических ограничений, которая будет пригодна для Ray-casting. Вместо того чтобы прослеживать луч для каждого пикселя на экране, мы можем проследить только для каждого вертикального столбца экрана. Луч в крайнем левом углу FOV будет проецироваться на столбец 0 плоскости проекции, а самый правый луч будет проецироваться на столбец 319 плоскости проекции.  
![](https://github.com/markveligod/cub3d/raw/master/img/17.jpg)  
Поэтому, чтобы визуализировать такую сцену, мы можем просто проследить 320 лучей, начиная слева направо. Это можно сделать в цикле. Ниже приведены примеры этих шагов:

* Исходя из угла обзора, вычтите 30 градусов (половина FOV).
* Начиная со столбца 0:  
  
  A) Бросьте луч. (Термин "актерский состав" немного сбивает с толку. Представьте себе игрока в роли волшебника, который может "бросать" лучи вместо заклинаний. Луч - это просто "воображаемая" линия, идущая от игрока.)  
  
  B) Проследите за лучом, пока он не упрется в стену.  
* Запишите расстояние до стены (расстояние равно длине луча).
* Добавьте приращение угла так, чтобы луч двигался вправо (мы знаем, что значение приращения угла равно 60/320 градусам).
* Повторяйте шаги 2 и 3 для каждой последующей колонки, пока не будут отброшены все 320 лучей.
Хитрость шага 2 заключается в том,что вместо проверки каждого пикселя нам нужно только проверить каждую сетку. Это происходит потому, что стена может появиться только на границе сетки. Рассмотрим прослеживаемый луч, как показано на рис. 14. Чтобы проверить, попал ли этот луч в стену или нет, достаточно проверить точки пересечения сетки в точках A, B, C, D, E и F.  
![](https://github.com/markveligod/cub3d/raw/master/img/18.gif)  
Чтобы найти стены, нам нужно проверить все точки пересечения сетки, с которыми сталкивается Луч; и посмотреть, есть ли стена на сетке или нет. Лучше всего проверять горизонтальные и вертикальные пересечения отдельно. Когда есть стена на вертикальном или горизонтальном пересечении, проверка останавливается. Затем сравнивается расстояние до обеих точек пересечения и выбирается более близкое расстояние.  
![](https://github.com/markveligod/cub3d/raw/master/img/19.gif)  
Этапы нахождения пересечений с горизонтальными линиями сетки:

* Найдите координату первого пересечения (точка а в данном примере).
* Найду Ya. (Примечание: Ya-это просто высота сетки; однако, если луч направлен вверх, Ya будет отрицательным, если луч направлен вниз, Ya будет положительным.)
* Найдите Xa, используя приведенное выше уравнение.
* Проверьте сетку в точке пересечения. Если на сетке есть стена, остановитесь и рассчитайте расстояние.
* Если стены нет, протяните ее до следующей точки пересечения. Обратите внимание, что координата следующей точки пересечения-назовем ее (Xnew, Ynew) - это Xnew=Xold+X a, а Ynew=YOld+Ya.
В качестве примера ниже приводится то, как вы можете получить точку а:  
```
*Примечание:* помните, что Декартовая координата увеличивается вниз, и любые дробные значения будут округлены вниз.

= = = = = = Нахождение горизонтального пересечения ======
1. Нахождение координаты точки A.
Если луч направлен вверх
`A.y = rounded_down(Py/64) * (64) - 1;`
Если луч направлен вниз
`A.y = rounded_down(Py/64) * (64) + 64;`

(На картинке луч направлен вверх, поэтому мы используем первую формулу)  

A. y=rounded_down(224/64) * (64) - 1 = 191;
Теперь на этом этапе мы можем узнать сетку координаты y.
Однако мы должны решить, является ли A частью блок над линией, или блок под линией.
Здесь мы решили сделать часть блока
выше линии, вот почему мы вычитаем 1 из A. y.
Таким образом, координата сетки A. y равна 191/64 = 2;

A. x = Px + (Py-A. y)/tan (Альфа);
На рисунке (предположим, что Альфа равна 60 градусам),
A. x=96 + (224-191) / tan (60) = около 115;
Координата сетки A. x равна 115/64 = 1;

Таким образом, A находится в сетке (1,2), и мы можем проверить
есть ли на этой решетке стена?
Там нет стены на (1,2), так что луч будет
продлено до с.

2. Найти Ya
Если луч направлен вверх
Yа=-64;
Если луч направлен вниз
Ya=64;

3. Найти Хa
Xa = 64 / tan(60) = 36;

4. Мы можем получить координату с следующим образом:
C. x=A. x+Xa = 115 + 36 = 151;
C. y=A. y+Ya = 191-64 = 127;
Преобразуйте это в координату сетки с помощью
деление каждого компонента на 64.
Результат таков
C. x = 151/64 = 2 (координата сетки),
C. y = 127/64 = 1 (координата сетки)
Таким образом, координата сетки C равна (2, 1).
(*Примечание программиста C:* помните, что мы всегда округляем вниз, это особенно верно, так как вы можете использовать правый сдвиг на 8, чтобы разделить на 64).  

5. Проверяется сетка (2,1).
Опять же, нет никакой стены, поэтому луч расширяется к a.  

6. Мы можем получить координату D следующим образом:
D. x=C. x+Xa = 151+36 = 187;
D. y=C. y+Ya = 127-64 = 63;
Преобразуйте это в координату сетки с помощью
деление каждого компонента на 64.
Результат таков
D. x = 187/64 = 2 (координата сетки),
D. y = 63/64 = 0 (координата сетки)
Таким образом, координата сетки D равна (2, 0).

6. Проверяется сетка (2,0).
Там есть стена, так что процесс остановится.
```  
*(Примечание программиста: вы можете видеть, что как только у нас есть значение Xa и Ya, процесс очень прост. Мы просто продолжаем добавлять старое значение с помощью Xa и Ya и выполняем операцию сдвига, чтобы узнать сеточную координату следующей точки, пораженной лучом.)*  
![](https://github.com/markveligod/cub3d/raw/master/img/20.gif)  
Этапы нахождения пересечений с вертикальными линиями сетки:

* Найдите координату первого пересечения (точка B в данном примере).
* Луч направлен прямо на изображение, поэтому B. x = rounded_down(Px/64) * (64) + 64.
* Если бы луч был обращен влево B. x = rounded_down(Px/64) * (64) – 1.
    A.y = Py + (Px-A. x)*tan (Альфа);
* Найти Хa. (*Примечание:* Xa - это только ширина сетки; однако, если луч направлен вправо, Xa будет положительным, если луч направлен влево, Ya будет отрицательным.)
* Найдите Ya, используя приведенное выше уравнение.
* Проверьте сетку в точке пересечения. Если на сетке есть стена, остановитесь и рассчитайте расстояние.
* Если стены нет, протяните ее до следующей точки пересечения. Обратите внимание, что координата следующей точки пересечения-назовем ее (Xnew, Ynew) - это просто Xnew=Xold+Xa, а Ynew=YOld+Ya.
* На рисунке, во-первых, луч попадает в точку B. сетка (2,2) проверяется. Там нет стены на (2,2), поэтому луч расширяется до E. сетка (3,0) проверена. Там есть стена, поэтому мы останавливаемся и вычисляем расстояние.

В этом примере точка D находится ближе, чем E. Таким образом, будет нарисован срез стены в точке D (а не E).  

## RAY-CASTING STEP 4: FINDING DISTANCE TO WALLS  
Существует несколько способов найти расстояние от точки обзора (игрока) до среза стены. Они проиллюстрированы ниже.  
![](https://github.com/markveligod/cub3d/raw/master/img/21.gif)  
Функции синуса или Косинуса дешевле реализовать, потому что они могут быть предварительно вычислены и помещены в таблицы. Это может быть сделано потому, что Альфа (POV игрока) должна быть от 0 до 360 градусов, поэтому количество возможностей ограничено (метод квадратного корня имеет практически неограниченные возможные значения для x и y).

Прежде чем рисовать стену, есть одна проблема, о которой необходимо позаботиться. Эта проблема известна как "эффект аквариума"."Эффект аквариума происходит потому, что реализация лучевого литья смешивает полярную координату и декартову координату вместе. Поэтому использование приведенной выше формулы на срезах стен, которые не находятся непосредственно перед зрителем, даст большее расстояние. Это не то, что мы хотим, потому что это вызовет искажение просмотра, как показано ниже.  
![](https://github.com/markveligod/cub3d/raw/master/img/22.gif)  
![](https://github.com/markveligod/cub3d/raw/master/img/23.gif)  
Таким образом, чтобы устранить искажение обзора, результирующее расстояние, полученное из уравнений на рис, должно быть умножено на cos(BETA); где BETA-угол луча, который отбрасывается относительно угла обзора. На рисунке выше угол обзора (Альфа) равен 90 градусам, потому что игрок смотрит прямо вверх. Поскольку у нас есть поле зрения 60 градусов, бета равна 30 градусам для самого левого луча и -30 градусам для самого правого луча.  
## RAY-CASTING STEP 5: DRAWING WALLS  
На предыдущих этапах было отброшено 320 лучей, и когда каждый луч попадает на стену, вычисляется расстояние до этой стены. Зная расстояние, срез стены можно затем спроецировать на проекционную плоскость. Для этого нужно найти высоту проектируемого среза стены. Оказывается, это можно сделать с помощью простой формулы:  
```
                           Фактическая Высота Среза  
Проецируемая высота среза= --------------------- * расстояние до плоскости проекции  
                            Расстояние до среза
```  
![](https://github.com/markveligod/cub3d/raw/master/img/24.gif)  
Наш мир состоит из кубов, где размер каждого куба составляет 64х64х64 единицы, поэтому высота стены составляет 64 единицы. Мы также уже знаем расстояние игрока до плоскости проекции (которое равно 277). Таким образом, уравнение может быть упрощено до:
Проекционная высота среза = 64 / расстояние до среза * 277

В реальной реализации можно рассмотреть несколько моментов:

Например, 64/277 может быть предварительно вычислено, так как это будет постоянное значение. После того, как это будет рассчитано, срез стены может быть нарисован на экране. Это можно сделать, просто проведя вертикальную линию по соответствующему столбцу на плоскости проекции (экране).

Помните, откуда взялся номер 277? Это число на самом деле может быть немного отклонено, не вызывая никакого огромного воздействия. На самом деле, это сэкономит время, чтобы использовать значение 255, потому что программист может использовать оператор сдвига для экономии вычислительного времени (сдвиг вправо на 3 для умножения, сдвиг влево для деления).

Например, предположим, что Луч в колонке 200 попадает в срез стены на расстоянии 330 единиц. Проекция среза будет такой 64 / 330 * 277 = 54 (округлено вверх).
Так как центр плоскости проекции определен равным 100. В этой точке должна появиться середина среза стены. Следовательно, верхняя позиция, в которой должен быть нарисован срез стены, равна 100-27=73. (где 27 - это половина от 54). Наконец, проекция среза будет выглядеть примерно так же, как на следующем рисунке.  
![](https://github.com/markveligod/cub3d/raw/master/img/25.gif)  

## TEXTURE MAPPED WALLS  
